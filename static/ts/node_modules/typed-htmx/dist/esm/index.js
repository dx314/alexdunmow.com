/// <reference path="./jsx.d.ts" />
/**
 * Configuration for the JSX runtime.
 */
export const jsxConfig = {
    jsonAttributes: new Set(["hx-vals", "hx-headers", "data-hx-vals", "data-hx-headers"]),
    sanitize: false,
    trusted: false,
};
const attrPattern = /[<>&"']/g;
const attrPatternWithoutDQ = /[<>&']/g;
const attrReplacements = {
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    '"': "&quot;",
    "'": "&#39;",
};
function isRenderable(value) {
    return value === 0 || !!value;
}
function attrSanitizer(raw) {
    return String(raw).replace(attrPattern, (sub) => attrReplacements[sub] || sub);
}
function attrSanitizerWithoutDQ(raw) {
    return String(raw).replace(attrPatternWithoutDQ, (sub) => attrReplacements[sub] || sub);
}
function htmlSanitizer(raw) {
    const out = String(raw);
    if (jsxConfig.trusted)
        return out;
    return jsxConfig.sanitize ? jsxConfig.sanitize(out, typeof raw) : out;
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function htmlTransformChildren(value) {
    if ("$$child" in value)
        return isRenderable(value.$$child) ? htmlSanitizer(value.$$child) : "";
    if ("$$children" in value) {
        const out = [];
        for (const child of value.$$children) {
            if (isRenderable(child))
                out.push(htmlSanitizer(child));
        }
        return out.join(" ");
    }
    let obj;
    if ("$$spread" in value && isObject(value.$$spread))
        obj = value.$$spread;
    else if (isObject(value))
        obj = value;
    else
        return "";
    const out = [];
    for (const key of Object.keys(obj)) {
        const attr = obj[key];
        if (!isRenderable(attr) && attr !== "")
            continue;
        if (jsxConfig.jsonAttributes.has(key)) {
            out.push(`${key}='${attrSanitizerWithoutDQ(JSON.stringify(attr))}'`);
        }
        else {
            out.push(`${key}="${attrSanitizer(attr)}"`);
        }
    }
    return out.join(" ");
}
/**
 * A [tagged template](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)
 * that interprets different kinds of {@link InterpValue values} into escaped HTML.
 *
 * ```ts twoslash
 * import { html } from 'typed-htmx';
 * function assertEqual(left: any, right: any) {}
 * // ---cut---
 * const template = html`
 *   <div hx-vals=${{ foo: 'bar' }} />
 * `;
 * assertEqual(template, `<div hx-vals='{"foo":"bar"}' />`);
 * ```
 */
export const html = (raw, ...values) => {
    const values_ = values.map(htmlTransformChildren);
    return String.raw(raw, ...values_);
};
